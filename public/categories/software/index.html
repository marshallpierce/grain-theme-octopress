<!DOCTYPE html> <!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]--> <!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]--> <!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]--> <head> <meta charset="utf-8"> <title>Category: Software - /var/blog</title> <meta name="author" content="Marshall Pierce"> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="canonical" href="http://varblog.org/categories/software/"> <link href="/images/favicon-eec3051d5c356d1798bea1d8a3617c51.png" rel="icon"> <link href="/stylesheets/screen-f19fe1e828d45fc5c662263acd7bd8b7.css" media="screen, projection" rel="stylesheet" type="text/css"> <link href="atom.xml" rel="alternate" title="/var/blog" type="application/atom+xml"> <script src="/javascripts/libs/jquery.min-663628f795cb62444143fde1ebdf2b5b.js" type="text/javascript"></script> <script src="/javascripts/modernizr-2.0-f86b862d5ee138da61daf47f24116ed7.js" type="text/javascript"></script> <script src="/javascripts/octopress-52bd0860c81b8af484852d75380d38f3.js" type="text/javascript"></script> <script src="/javascripts/github-2c23ec60bbc7e962f6324b25d8b2ae44.js" type="text/javascript"></script> <script src="/javascripts/jquery.tweet-408e79928ca077df30b72fe36df5754e.js" type="text/javascript"></script> <script src="/javascripts/twitter-options-cb3077a900fb191dd4cfa23ac1d4bb5f.js" type="text/javascript"></script> <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-24874793-2', 'varblog.org');
    ga('send', 'pageview');

</script> <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> </head> <body> <header role="banner"><hgroup> <h1><a href="/">/var/blog</a></h1> <h2>by Marshall Pierce</h2> </hgroup> </header> <nav role="navigation"><ul class="subscription" data-subscription="rss "> <li><a href="http://varblog.org/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li> </ul> <form action="http://google.com/search" method="get"> <fieldset role="search"> <input type="hidden" name="q" value="site:http://varblog.org"/> <input class="search" type="text" name="q" results="0" placeholder="Search"/> </fieldset> </form> <ul class="main-navigation"> <li><a href="/">Blog</a></li> <li><a href="/archives/">Archives</a></li> </ul> </nav> <div id="main"> <div id="content"> <div class="blog-index"> <article> <h1 id="entry-title">Category: Software</h1> <div class="subscribe"> <a rel="subscribe-rss" title="Stay tuned to Software category via RSS" href="/categories/software/atom.xml">RSS</a> </div> <article> <header> <h1 class="entry-title"><a href="/blog/2018/01/08/rust-and-webassembly-with-turtle/">Rust and WebAssembly With Turtle</a></h1> <p class="meta"> <time datetime="2018-01-08T09:54:00-06:00" pubdate data-updated=true> <span class="month">Jan</span> <span class="day">08</span>, <span class="year">2018</span> </time> </p> </header> <div class="entry-content"><p>In this post, I'll walk through a few of the highlights of getting <a href="http://turtle.rs/">Turtle</a>, a Rust library for creating animated drawings, to run in the browser with WebAssembly.</p> <p>Rust has <a href="https://github.com/rust-lang/rust/pull/46115">recently</a> gained built-in support for compiling to <a href="http://webassembly.org/">WebAssembly</a>. While it's currently considered experimental and has some rough edges, it's not too early to <a href="https://www.hellorust.com/">start seeing what it can do with some demos</a>. After an <a href="https://bitbucket.org/marshallpierce/rust-wasm-base64">experiment running rust-base64 via WebAssembly</a> with surprisingly good performance, I saw <a href="https://twitter.com/gcouprie/status/938842985906700288">this tweet</a> suggesting that someone port Turtle to run in the browser, and figured I'd give it a try <a href="https://github.com/sunjay/turtle/pull/53">(see PR)</a>. Turtle is a more interesting port than rust-base64's low level functionality: it's larger, and has dependencies on concepts that have no clear web analog, like forking processes and desktop windows. You can run it yourself with any recent browser; just follow <a href="https://github.com/sunjay/turtle/pull/53/files#diff-e3d3691703168e79428c9bd1c084f5bc">these instructions</a>.</p> <h2>Why Rust + WebAssembly?</h2> <p>See the <a href="http://webassembly.org/">official WebAssembly site</a> for more detail, but in essence WebAssembly is an escape hatch from the misery of JavaScript as the sole language runtime available in browsers. Even though it's already possible to transpile to JavaScript with tools like emscripten or languages like TypeScript, that doesn't solve problems like JavaScript's lack of proper numeric types. WebAssembly provides a much better target for web-deployed code than JavaScript: it's compact, fast to parse, and JIT compiler friendly.</p> <p>WebAssembly is not competition for JavaScript directly. It's more akin to JVM bytecode. This makes it a great fit for Rust, though, which has a minimal runtime and no garbage collector.</p> <h2>Turtle</h2> <p>Turtle is a library for making little single-purpose applications that draw graphics ala the <a href="https://en.wikipedia.org/wiki/Logo_%28programming_language%29">Logo</a> language. See below for a simple program (the <a href="https://github.com/sunjay/turtle/blob/5db76f7d12baa6676f84088432e1896c42da80c6/examples/snowflake.rs"><code>snowflake</code></a> example in the Turtle repo) that's most of the way through its drawing logic.</p> <p><img class='centered' src="/images/turtle/koch-snowflake-d35530a36ba6f0eb6cb7c5f183c0b609.png"/></p> <h3>Turtle's existing architecture</h3> <p>Turtle is designed to be friendly to beginner programmers, so unlike most graphics-related code, it's not based around the concept of an explicit render loop. Instead, Turtle programs simply take over the main thread and run straightforward-looking code like this (which draws a circle):</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span></span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">360</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="c1">// Move forward three steps</span>
</span><span class='line'><span class="w">    </span><span class="n">turtle</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="c1">// Rotate to the right (clockwise) by 1 degree</span>
</span><span class='line'><span class="w">    </span><span class="n">turtle</span><span class="p">.</span><span class="n">right</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span><span class="w"></span>
</span><span class='line'><span class="p">}</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure> <p>The small pauses needed for animation are implicit, and programmers can use local variables in a natural way to manage state. This has some implications for running in the browser, as we'll see.</p> <h2>Compiling to <code>wasm32</code></h2> <p>As with any wasm project, the first step is to get the toolchain:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span></span>rustup update
</span><span class='line'>rustup target add wasm32-unknown-unknown --toolchain nightly
</span></code></pre></td></tr></table></div></figure> <p>Hypothetically, this would be all that's needed to compile the example turtle programs:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span></span>cargo +nightly build --target<span class="o">=</span>wasm32-unknown-unknown --examples
</span></code></pre></td></tr></table></div></figure> <p>However, there were naturally some dependencies that didn't play nice with the wasm32 target, mainly involving <a href="https://github.com/pistondevelopers/piston">Piston</a>, the graphics library used internally. Fortunately, Piston's various crates are nicely broken down to separate the platform-specific parts from platform-agnostic things like math helper functions, so introducing a <code>canvas</code> feature to control Piston dependencies (among other things) was all that was needed. That brings us to:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span></span>cargo +nightly build --no-default-features --features<span class="o">=</span>canvas --target<span class="o">=</span>wasm32-unknown-unknown --release --examples
</span></code></pre></td></tr></table></div></figure> <h2>Control flow</h2> <p>The current architecture of a Turtle program running on a desktop uses two processes: one to run the user's logic, and another to handle rendering. When the program starts, it first forks a render process, then passes control flow to the user's logic in the parent process. When code like <code>turtle.forward()</code> runs, that ends up passing drawing commands (and other communication) via stdin/stdout to the child rendering process, which uses those to draw into a <a href="https://github.com/pistondevelopers/piston">Piston</a> window. The two-process model allows graphics rendering to be done by the main thread (which is required on macOS) while still allowing users to simply write a <code>main()</code> function and not worry about how to run their code in another thread.</p> <p>Turtle code doesn't let go of control flow until the drawing has completed. This isn't a problem when Turtle code is running in one process and feeding commands to another process to be rendered to the screen, but browser-resident animation <em>really</em> wants to run code that runs a little bit at a time in an event loop via <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame()</code></a>. The browser doesn't update the page until control flow for your code has exited. This has some upsides for browsers (no concerns about thread safety when all code is time-sliced into one thread, for instance), but it in Turtle's case, it means that running in the main thread would update the screen exactly once: when the drawing was complete.</p> <p>We do have one trick up our sleeve, though: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a>. These allow simple parallelism, but there is no good way to share memory with a worker and the main thread. (Aha, you say! What about <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</a>? Nope, it's been disabled due to <a href="https://spectreattack.com/">Spectre</a>.) What we <em>can</em> do, though, is send messages to the main thread with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage"><code>postMessage()</code></a>. This way, we can create a worker for Turtle, let it take over that thread entirely, and periodically post messages to be sent to the main thread when it wants to update the UI.</p> <h2>Drawing pixels</h2> <p>Let's consider a very simple Turtle program where the user wishes to draw a line. This boils down to <code>turtle.forward(10)</code> or equivalent. However, this isn't going to get all 10 pixels drawn all at once, because the turtle has a speed. So, it will calculate how long it should take to draw 10 pixels, and draw intermediate versions as time goes on. The same applies when drawing a polygon with a fill: the fill is partially applied at each point in the animation as the edges of the polygon are drawn. As parts of the drawing accumulate over time as the animation continues, the <code>Renderer</code> keeps track of all of them and re-draws them with its Piston <code>Graphics</code> backend every frame.</p> <p>Naturally, the existing graphics stack that uses <code>piston_window</code> to draw graphics into a desktop app's window isn't going to seamlessly just start running in the browser and render into a <code>&lt;canvas&gt;</code>. So, where should the line be drawn about what is desktop-specific (and will therefore have to be reimplemented for the web)?</p> <p>One option would be to reimplement the high level turtle interface (<code>forward()</code>, etc) in terms of Canvas drawing calls like <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath"><code>beginPath()</code></a>. While it certainly can be done, it would require reimplementing a lot of code that animates, manages partially-completed polygons, draws the turtle itself, etc. The messages sent to the main thread would likely be a a JS array of closures which, when executed in the appropriate context, would update the <code>&lt;canvas&gt;</code> in the web page. Alternately, the canvas commands to run could be expressed as Objects with various fields, etc. This saves us from worrying about low level pixel wrangling, but at the cost of creating two parallel implementations of some nontrivial logic, one of which is quite difficult to test or reason about in isolation. It also means that as the drawing gets more complex over time, the list of commands to run grows as well, so performance will decay over time. It also involves many small allocations (and consequently more load on the JS GC).</p> <p>Another approach would be to implement the Piston <code>Graphics</code> trait in terms of the Canvas API. This entails a lot less code duplication because things like animation, drawing the turtle "head" triangle, etc can all be re-used, but it still suffers from the performance decay over time, and has a fair amount of logic that needs to be built in JS, which I was trying to avoid. It's definitely much more practical than the previous option, though.</p> <p>The approach I chose was to implement <code>Graphics</code> to write to an RGBA pixel buffer, which is easy to then display with a <code>&lt;canvas&gt;</code>. This has a minimal amount of JS needed, and has heavy, but consistent, allocation and message passing cost. Each frame requires one (large) allocation to copy the entire pixel buffer, which is then sent to the main thread and used to update the <code>&lt;canvas&gt;</code>. Obviously there are various ways to optimize this (only sending changed sub-sequences of pixels, etc) but for a first step, sending the entire buffer was functional and reliable. For Turtle's needs, <code>Graphics</code> only needs to draw triangles with a solid fill, which is pretty straightforward.</p> <h2>Passing control flow to Turtle</h2> <p>Getting from <code>main()</code> to Turtle logic is actually a little complicated even when running on a desktop, as mentioned above. It is undesirable to have users deal with running turtle code in a different thread, so instead while Turtle is initializing it does its best to fork at the right time. If users are doing nontrivial initialization code of their own (e.g. parsing command line arguments), they have to be careful to let Turtle fork at the right point.</p> <p>When running as wasm inside a Worker, initialization is convoluted in a different way. When writing a <code>main()</code> function for a normal OS, all the context you might want is available via environment variables, command line parameters, or of course making syscalls, but there's nothing like that for wasm unless you build it yourself. While you can declare a <a href="https://webassembly.github.io/spec/core/syntax/modules.html#start-function">start function</a> for a wasm module, that doesn't solve our problem since this wasm code depends on knowledge from its environment, like how many pixels are in the canvas it will be drawing to.</p> <p>While I could have doubled down on "call <code>Turtle::new()</code> at the right point and hope that it will figure it out" by having some wasm-only logic that called into the JS runtime to figure out what it needed, a small macro seemed like a tidier solution. The macro uses conditional compilation to do the right thing when it's compiled for the desktop or for wasm, with straightforward, global-free code in each case.</p> <p>Before:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="c1">// Must start by calling Turtle::new()</span>
</span><span class='line'><span class="w">    </span><span class="c1">// Secretly forks a child process and takes over stdout</span>
</span><span class='line'><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">turtle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Turtle</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="c1">// write your drawing code here</span>
</span><span class='line'><span class="p">}</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure> <p>After:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span></span><span class="n">run_turtle</span><span class="o">!</span><span class="p">(</span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">turtle</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="c1">// write your drawing code here</span>
</span><span class='line'><span class="p">});</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure> <p>It's harder for users to screw up, and it opens the way to putting the Turtle logic in its own thread (instead of forking) when running on a desktop. This would allow users to use stdout on the desktop (currently claimed for communication with the child process), and the underpinnings could simply use shared memory instead of doing message passing via json over stdin/stdout. And, of course, it lets us get the right wasm-only initialization code in there too!</p> <p>Anyway, with that in place, initializing the Worker that hosts the wasm is simple enough (see <a href="https://github.com/sunjay/turtle/pull/53/files#diff-8a5b5909f5b3ce1a25a1c499ab30da2c">worker.js</a>). Following <a href="https://www.hellorust.com/demos/canvas/index.html">Geoffroy Couprie's canvas example</a>, we simply allocate a buffer with 4 bytes (RGBA) per pixel and call this function provided by the <code>run_turtle!</code> macro to kick things off:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span></span><span class="cp">#[allow(dead_code)]</span><span class="w"></span>
</span><span class='line'><span class="cp">#[cfg(feature = </span><span class="s">&quot;canvas&quot;</span><span class="cp">)]</span><span class="w"></span>
</span><span class='line'><span class="cp">#[no_mangle]</span><span class="w"></span>
</span><span class='line'><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">web_turtle_start</span><span class="p">(</span><span class="n">pointer</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">width</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">height</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="n">turtle</span>::<span class="n">start_web</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="cp">$f</span><span class="p">);</span><span class="w"></span>
</span><span class='line'><span class="p">}</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure> <p>When a new frame has been rendered, the Rust logic calls into JS, which copies the contents of the pixel buffer and sends it to the main thread, which simply drops it into the <code>&lt;canvas&gt;</code>.</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span></span><span class="kr">const</span> <span class="nx">pixelArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8ClampedArray</span><span class="p">(</span><span class="nx">wasmTurtle</span><span class="p">.</span><span class="nx">memory</span><span class="p">.</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">pointer</span><span class="p">,</span> <span class="nx">byteSize</span><span class="p">);</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">copy</span> <span class="o">=</span> <span class="nx">Uint8ClampedArray</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">pixelArray</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="nx">postMessage</span><span class="p">({</span>
</span><span class='line'>    <span class="s1">&#39;type&#39;</span><span class="o">:</span>   <span class="s1">&#39;updateCanvas&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;pixels&#39;</span><span class="o">:</span> <span class="nx">copy</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure> <h2>Random number generation</h2> <p>When Rust is running on a normal OS, it uses <code>/dev/random</code> or equivalent internally to seed a PRNG. However, WebAssembly isn't an OS, so it doesn't offer a source of random numbers (or files, for that matter, in the same way that x86 asm doesn't have files). In practice, this means that Turtle's use of <code>rand::thread_rng()</code> dies with an "unreachable code" error.</p> <p>Fortunately, implementing our own <code>Rng</code> is pretty straightforward: the only required method is <code>next_u32()</code>, and that much we can do with JavaScript and the browser's PRNG (32 bit ints are pretty sane in JS; major int weirdness starts at 2^52). First, we'll need a JS function to make a random number between <code>0</code> and <code>u32::max_value()</code>, using the normal random range idiom:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span></span><span class="nx">web_prng</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kr">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="mi">4294967295</span><span class="p">;</span> <span class="c1">// u32 max</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="nx">min</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure> <p>By making that available to the wasm module when it's initialized, we can then make that callable from Rust:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="k">fn</span> <span class="nf">web_prng</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span><span class="p">;</span><span class="w"></span>
</span><span class='line'><span class="p">}</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure> <p>And then use it in our <code>Rng</code> implementation:</p> <figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">WebRng</span><span class="p">;</span><span class="w"></span>
</span><span class='line'>
</span><span class='line'><span class="k">impl</span><span class="w"> </span>::<span class="n">rand</span>::<span class="n">Rng</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WebRng</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="k">fn</span> <span class="nf">next_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">            </span><span class="n">web_prng</span><span class="p">()</span><span class="w"></span>
</span><span class='line'><span class="w">        </span><span class="p">}</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="p">}</span><span class="w"></span>
</span><span class='line'><span class="p">}</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure> <p>All that remained was to adjust how Turtle exposed random numbers so that it would use the appropriate <code>Rng</code> implementation on a desktop OS vs on wasm.</p> <h1>Conclusion</h1> <p>Hopefully this has demonstrated that getting Rust code running in the browser via wasm is pretty achievable even for projects that aren't a drop-in fit for the browser's runtime model.</p> <p>There were other problems to solve (like measuring time, or being able to println for debugging), but this post is already pretty long, so I'll refer you to the <a href="https://github.com/sunjay/turtle/pull/53">pull request</a> if you want all the details.</p> </div> </article> <article> <header> <h1 class="entry-title"><a href="/blog/2015/03/29/developers-debate-unimportant-things/">Developers Debate Unimportant Things</a></h1> <p class="meta"> <time datetime="2015-03-29T14:56:00-05:00" pubdate data-updated=true> <span class="month">Mar</span> <span class="day">29</span>, <span class="year">2015</span> </time> </p> </header> <div class="entry-content"><p>The other day I read a disappointing screed by a determined developer. The specific text is unimportant, but I'm sure you've read plenty just like it: claims about technology X that the author doesn't like, while simultaneously promoting technology Y that they do like as a technological panacea. Now you know why the specific article is irrelevant -- it could be Sass vs Less, or CoffeeScript vs Dart, or Maven vs Gradle, or K&amp;R vs BSD curly brace placement, and any of those hypothetical articles could be extracted from another with find and replace.</p> <p>Consider the case of a hypothetical team with a background in technology <em>X</em> that starts a new project in (or migrates to) technology <em>Y</em>. The new work goes well, and the team is enthused about <em>Y</em>. The question is, though, how important is <em>Y</em> specifically to the success of the project? Sometimes, of course, there are cases where technology choice can be a huge factor. Trying to write firmware for an embedded device with an 8K ROM in C++ template metaprogramming (it's Turing-complete, so why not?) is probably not going to go well. I'll set aside these hyperbolic cases, though, as they're rare and easily avoided with a little googling. Let's go back to our hypothetical team and consider the contributions of the following aspects of their successful project:</p> <ul> <li>Choosing <em>Y</em> instead of sticking with <em>X</em> or choosing another option <em>Z</em></li> <li>The architectural cleanliness that comes from an at least partially blank slate</li> <li>Having team members who care about improvement</li> <li>Having team members who know that improvement is possible</li> <li>Engineering leadership's trust in the team's decisions on what to do</li> <li>The organizational health needed to work around a departure from the business-as-usual schedule</li> <li>The corporate political bonhomie needed to allow the engineering organization to innovate rather than take the safe road of continuing with what they already have</li> </ul> <p>I assert that in the common case, the success or failure of a project generally has little to do with the specific technology used. In one way, this is not a radical assertion: the importance of organizational structure, team culture, and other such intangibles has been known for decades. (This is what management is all about, after all.) My point is that even though technology usually isn't the important part, <em>developers argue as if it is</em>. Developers are generally detail oriented, and many (though not all) are also equipped with a surfeit of opinions. Consider topics like compile time vs runtime type checking, Java vs Scala, tabs vs spaces... We can quantify these topics, so we can bring facts (or at least aesthetics) to bear as we bicker over relative merits. My own experience is, of course, only anecdotal evidence, but across the projects I've been involved in both as a regular employee and as a consultant, the choice of technology hasn't been nearly as important to overall productivity as the team's engineering maturity, organizational health, etc. In conversation with fellow technologists, I've found I'm not the only one.</p> <p><img src="/images/developers-debate-unimportant-things-0d15db1e1d5af7724c0cc8c0b4701511.png"/></p> <p>It's understandable that we might tend to attach too much importance to the things that we know well and have some control over, so where do we go from here? I definitely don't want to write off the value of a good ol' my-type-inference-is-better-than-your-type-inference debate; we all learn a lot from the exchange of ideas. Instead, I think that when we debate such things we have to keep in mind that it's only a small part of success, and that ultimately the specific technology probably doesn't matter much. If you have an opportunity to adopt your technology-du-jour because your team has the political will and organizational freedom to do so, you will have necessarily already succeeded at the hard part: being part of an organization that allows for success in the first place. On the other hand, if you're struggling to get momentum adopting a technology that you're confident will help your project, consider that the tech isn't your problem: it's that you're the only one clamoring for improvement.</p> </div> </article> </article> <div class="pagination"> <div class="links"> </div> </div> </div> <aside class="sidebar"> <section> <h1>Recent Posts</h1> <ul id="recent_posts"> <li class="post"> <a href="/blog/2018/05/24/profiling-and-optimizing-machine-learning-model-training-with-pytorch/">Profiling and Optimizing Machine Learning Model Training With PyTorch</a> </li> <li class="post"> <a href="/blog/2018/01/08/rust-and-webassembly-with-turtle/">Rust and WebAssembly With Turtle</a> </li> <li class="post"> <a href="/blog/2016/01/21/diy-bike-hoist/">DIY Bike Hoist</a> </li> <li class="post"> <a href="/blog/2015/03/29/developers-debate-unimportant-things/">Developers Debate Unimportant Things</a> </li> <li class="post"> <a href="/blog/2014/01/05/blogging-with-grain-and-s3/">Blogging With Grain and S3</a> </li> </ul> </section> <section> <h1>BitBucket Repos</h1> <a href="https://bitbucket.org/marshallpierce">marshallpierce</a> on BitBucket </section> <section> <h1>GitHub Repos</h1> <a href="https://github.com/marshallpierce">marshallpierce</a> on GitHub </section> <section> <h1>My Tweets</h1> <div class="tweet query footer"></div> <a href="https://twitter.com/runswithbricks" class="twitter-follow-button" data-show-screen-name="true" data-show-count="true" data-lang="en" data-size="large"> Follow @runswithbricks </a> <script>!function (d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (!d.getElementById(id)) {
            js = d.createElement(s);
            js.id = id;
            js.src = "//platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js, fjs);
        }
    }(document, "script", "twitter-wjs");
    </script> </section> <section> <h1>About Me</h1> <p>Software, fitness, other stuff.</p> </section> <section class="social"> <h1> <a href="https://twitter.com/runswithbricks"> <div class="icon twitter-icon"></div> Twitter </a> </h1> </section> <section class="social"> <h1> <a href="https://plus.google.com/110635469877623035575?rel=author"> <div class="icon gplus-icon"></div> Google+ </a> </h1> </section> </aside> </div> </div> <footer role="contentinfo"><p> Copyright &copy; 2018 - Marshall Pierce - <span class="credit">Powered by <a href="http://sysgears.com/grain/">Grain</a></span> </p> </footer> </body> </html>